---
title: "05 Estimating goodness of fit and confidence intervals"
author: "Andrew Balmer"
date: "19/12/2023"
output: html_document
---

### ==== Aims and objectives of this Rmarkdown

It is important to ensure MDS solutions represent the data accurately. There are several methods to estimate the goodness-of-fit of an MDS solution (https://doi.org/10.1080/00273171.2016.1235966). Here, I have used several methods to estimate the stability of the map for the S. pneumoniae beta-lactam phenotype map. 

```{r setup, include=FALSE}

# Clear the workspace
remove(list = ls())

# Load required packages
library(tidyverse)     # For data manipulation and visualization
library(smacof)        # For multidimensional scaling
library(RColorBrewer)  # For color palettes

# Set the working directory
setwd("/Users/ajb306/AMR-cartography/analysis/#01-Phenotype_and_map_analyses/#07-10-Estimating-goodness-of-fit")

# Read the MIC table data
tablemic <- read.csv("/Users/ajb306/AMR-cartography/data/MIC_table_Spneumoniae.csv", header=TRUE, sep=",", skip = 0)

# Specify the full path to the data file
phen_map <- "/Users/ajb306/AMR-cartography/analysis/#01-Phenotype_and_map_analyses/#03-06-Generating-phenotype-and-genotype-maps/Spneumo_3628_PCA_start_2D_METRIC.RData"

# Load the precomputed PCA start 2D metric data
load(phen_map)

```

### ========= Stress output of isolate points
Firtly, I have visualised the isolate point error in different ways, this first plot shows the percentage of stress contributed by each isolate point. Ideally isolate points should contribute to stress more or less equally. For most MDS solutions there are outliers, as seen here. However, generally, the mean and standard deviation of stress contributions per point is low.

```{r, echo=FALSE}

# Calculate and display mean and standard deviation of stress values
mu <- as_tibble(torg_met$spp) %>%
  ungroup() %>%
  summarize(Mean = mean(value),
            sd = sd(value)) %>%
  round(3)

# Histogram of stress per point (%)
x <- as_tibble(torg_met$spp)
B <- ggplot(x, aes(x=value)) + 
  geom_histogram(position="identity", alpha = 0.5, color = "black", fill = "#E41A1C", bins = 30) +
  geom_vline(aes(xintercept=mean(value)),
            color="#E41A1C", linetype="dashed", size=1) + 
  theme_bw() +
  scale_x_continuous(breaks=seq(0,.5, .1)) +
  labs(x = "Per point stress contribution (%)", y = "Count") +
  # Add mean and sd labels at the top of the plot
  annotate("text", x = 0.25, y = 2500,
           label = paste("Mean:", mu$Mean, "\nSD:", mu$sd),
           vjust = 1, hjust = 0.5, color = "black", size = 3) 

# Display the histogram
B


```


### ========= Comparing table v map distances using a linear model

Next, we test the accuracy of the map using a linear model of the measured distances (table distances), against distances on the map (map distances). Ideally, a R-squared of 1 would mean the true values as measured are perfectly represented on the map. Here, you can see R-squared and Pearsons correlation coefficient for the phenotype map is high (>0.999), and the intercept is near 1. 

However, one complication is that to estimate error in fitting the points, the map transformation needs to be scaled to be interpretable (i.e. 1 unit on the map should equal 1 MIC unit in the assay). To make the map and the table distances comparable, we use the slope of the linear model to dilate the map to the correct scale. Lastly, we then rotate the map for plotting later in the markdown.

```{r, echo = F}

# Convert torg_met[[1]] and torg_met[[3]] to tibbles and set column names
table_distances <- as_tibble(as.matrix(torg_met[[1]]))
map_distances <- as_tibble(as.matrix(torg_met[[3]]))
colnames(map_distances) <- colnames(table_distances)

# Reshape data using gather function
table_distances <- gather(table_distances, "antibiotic", "table_distance", 1:nrow(tablemic)) 
map_distances <- gather(map_distances, "antibiotic", "map_distance", 1:nrow(tablemic))

# Combine table_distances and map_distances into a single tibble
distances <- bind_cols(table_distances, map_distances)

# Convert distances to numeric
distances$table_distance <- as.numeric(distances$table_distance)
distances$map_distance <- as.numeric(distances$map_distance)

# Fit linear model and display summary
mapvtable <- lm(map_distance ~ table_distance, data = distances)
summary(mapvtable)

# Perform Pearson correlation test
cor.test(distances$table_distance, distances$map_distance, method = "pearson")

# Extract slope and calculate dilation factor
slope <- as.numeric(coef(mapvtable)[2])
dilation <- 1 / slope
slope
colnames(torg_met$conf) <- c("D1", "D2")

# Apply dilation to each column in torg_met$conf
for (i in 1:ncol(torg_met$conf)) {
  torg_met$conf[, i] <- torg_met$conf[, i] * dilation
}

# Rotate configuration by 326 degrees
theta <- 326 * pi / 180 ## degrees to radians
rot <- matrix(c(cos(theta), sin(theta), -sin(theta), cos(theta)), ncol = 2)
torg_met$conf <- torg_met$conf %*% rot ## rotated configurations

# Modify distances tibble by scaling map_distance and calculating residuals
distances <- distances %>%
  mutate(map_distance = map_distance * dilation, 
         residuals = table_distance - map_distance)

```


### ========= Estimating Goodness-of-fit statistics

Next we estimate goodness of fit statistics for the phenotype map. The goodness-of-fit of an MDS plot can be investigated by calculating the proportion of errors above certain thresholds and investigating the distribution of stress-per-point (as a % of total stress). 

A Shepard plot can be used to show the relationship between measured pairwise table distances against the pairwise map distances. This plots the measured distances (table distances) between isolates on the x axis against the distances between isolates on the map. The stronger this relationship, the better the map fits the data. This relationship can be assessed quantitatively using a linear model (see above). Overall, the phenotype map fits the data accurately, with the slope and R2 of the Shepard plot linear model close to 1, and intercept close to 0. There are relatively few points more than 1 MIC unit away from their target distances.

```{r, echo = F}

# Create a tibble containing distinct values of residuals and their counts
distances_distinct_res <- distances %>%
  add_count(abs(residuals)) %>%
  distinct(abs(residuals), .keep_all=TRUE)

# Calculate the percentage of residuals greater than 1 and 2
percentage_above_1 <- sum(distances$residuals > 1) / nrow(distances) * 100
percentage_above_2 <- sum(distances$residuals > 2) / nrow(distances) * 100

# Calculate and display mean and standard deviation of residuals
mu <- distances %>%
  ungroup() %>%
  summarize(Mean = mean(residuals),
            sd = sd(residuals)) %>%
  round(3)

# Print mean and sd of errors
mu

# Create a histogram of absolute errors with mean line
ggplot(distances_distinct_res, aes(x = abs(residuals))) + 
  geom_histogram(position = "identity", alpha = 0.5, color = "black", fill = "#E41A1C", bins = 30) +
  geom_vline(aes(xintercept = mean(abs(residuals))),
             color = "#E41A1C", linetype = "dashed", size = 1) + 
  theme_bw() +
  labs(x = "Absolute error (MIC units)", y = "Count") 

  ggsave("dist_phen_histogram_spneumo_phen.jpg")
  

# Create a scatter plot of table_distance vs map_distance with diagonal reference lines 
C <- ggplot(distances_distinct_res, aes(x = table_distance, y = map_distance)) +
  geom_point(shape = 16, alpha = 0.1, colour = "#E41A1C", size = 0.75) +
  geom_abline(intercept = -1, slope = 1, linetype = "dashed", size = 0.5) +
  geom_abline(intercept = 0, slope = 1, linetype = "solid", size = 0.5) +
  geom_abline(intercept = 1, slope = 1, linetype = "dashed", size = 0.5) +
  geom_abline(intercept = as.numeric(coef(mapvtable)[1]), slope = as.numeric(coef(mapvtable)[2]) * dilation,
              linetype = "solid",  colour = "blue", size = 0.5) +
  theme_bw() +
  theme(panel.grid.major = element_line(colour = "grey", size = (0.1)),
        panel.grid.minor = element_blank()) +
  coord_fixed() +
  labs(x = "Table distance (MIC units)", y = "Map distance (MIC units)") +
  scale_x_continuous(breaks = seq(min(distances$table_distance), max(distances$table_distance) + 1, 1)) +
  scale_y_continuous(breaks = seq(min(distances$map_distance), max(distances$map_distance + 1), 1))

# Display the scatter plot (may take a while to load given the number of pairwise points)
C

# Save the scatter plot as an image
ggsave("shephard_plot_spneumo_phen.jpg")

```

### ==== Bubbleplot
The next plot is a 'bubblepot' where the size and colour of each isolate point is determined by their stress contribution as a percentage of total stress. The larger points represent points which contribute more stress. Ideally, the points across the map should have relatively similar stress contributions i.e. be the same size.

One thing to note here is that points which contributing the most stress may be suggestive of error in the assay for that point. One method would be to re-measure isolates above a certain stress threshold to ensure their MIC values are indeed repeatable. If this stress genuinely represents a unique phenotype that isnt due to error, and that it is not captured in two dimensions, this can be further examined in the genotype-phenotype comparison.

```{r, echo = F}

# Extract stress per point from MDS object and plot bubbleplot
bubbleplot <- as.data.frame(cbind(torg_met$conf))

#Extract stress values
bubbleplot$stress_per_point_as_percent <- torg_met$spp
colnames(bubbleplot) <- c("D1","D2","stress_per_point_as_percent")
         
# Create a bubble plot
A <- ggplot(bubbleplot, aes(x = D1, y = D2, fill = as.numeric(stress_per_point_as_percent), size = stress_per_point_as_percent)) +
  geom_point(shape = 21, alpha = 0.9, colour = "black") +
  scale_fill_gradient(low = "yellow", high = "red") + 
  theme_linedraw() +
  scale_x_continuous(limits = c(min(bubbleplot$D1), max(bubbleplot$D1) + 0.5), breaks = seq(min(bubbleplot$D1), max(bubbleplot$D1) + 1, 1)) +
  scale_y_continuous(limits = c(min(bubbleplot$D2), max(bubbleplot$D2) + 0.5), breaks = seq(min(bubbleplot$D2), max(bubbleplot$D2 + 1), 1)) +
  theme(panel.grid.major = element_line(colour = "grey", size = 0.3),
        panel.grid.minor = element_blank(),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.background = element_rect(fill = "white", size = 0.25, linetype = "solid", colour = "black")) + 
  scale_size_continuous(range = c(2, 8)) +
  guides(size = "none", fill = guide_legend(title = "Stress (%)", override.aes = list(size = 5))) +
  theme(legend.position = c(0.85, 0.2)) +
  coord_fixed()

# Display the bubble plot
A

# Save the bubble plot as an image
ggsave("bubble_plot_spneumo_phen.png")


```


### ========= Jack-knifing analysis
Depending on the dataset and method used, some MDS solutions can be 'unstable', i.e. they generate clearly different patterns depending on the sample used.

One method of examining the stability of an MDS solution is to use a Jackknife analysis. Jackknifing a MDS plot involves making a series of maps where each isolate is individually dropped while keeping all others, and each of these maps is compared to the full map. If the positions of the isolates are largely the same regardless of when any individual isolate is dropped, then the map is considered  stable. 

The plot shows the jackknife configurations which are connected to their centroid. The original configuration are also plotted. The Jackknife function itself returns also a stability measure (as ratio of between and total variance), a measure for cross validity, and the dispersion around the original SMACOF solution.


```{r,echo = F}

# Jack-knifing - warning - the following code will take a long time to run
#jack_optimised <- jackmds(torg_met, itmax = 100, verbose = FALSE)  
#jack_optimised
#plot(jack_optimised, hclpar = list(c = 80, l = 40))
#save(jack_optimised, file="Spneumo_3658_PCA_start_jackknife_beta-lactams.RData")

```



### =====  Bootstrapping of isolates and procrustes
Depending on the dataset and method used, some MDS solutions can be 'unstable', i.e. they generate different patterns depending on the sample used.

Another method of examining the stability of an MDS solution is to bootstrap the sample of isolates used. Bootstrapping a MDS plot involves making a series of maps where the data are bootstrapped sampled with replacement, and each of these maps is compared to the full map. If the positions of the isolates are largely the same regardless of the sample used, then the map is considered more stable.

```{r, echo = F}

# bootstrap resampling
bootRogers <- ?bootmds(torg_met, t(tablemic), method.dat = "euclidean", 
                      alpha = 0.95, 
                      nrep = 5, 
                      verbose = T)
bootRogers

save(bootRogers, file="Spneumo_3628_PCA_start_bootstrap_beta-lactams.RData")
load("Spneumo_3628_PCA_start_bootstrap_beta-lactams.RData")

ellipses <- plot(bootRogers, ell = list(lty = 2, col = "gray", lwd = 0.8))
test <- bind_rows(ellipses)
bootRogers

ellipses_conf <- list()

for (i in 1:nrow(tablemic)){
ellipses_conf[[i]] <- as_tibble(ellipses[[i]]) %>% select(c(1,2)) %>%
  rename("D1" = 1,
         "D2" = 2) %>%
  mutate(ID = i)
}

ellipses_conf <- bind_rows(ellipses_conf)


ellipses_conf <- ellipses_conf %>% 
  mutate(D1 = D1 *dilation,
         D2 = D2 *dilation)

  
#theta <- 326*pi/180 ## degrees to radians
#rot <- matrix(c(cos(theta), sin(theta), -sin(theta), cos(theta)), ncol = 2)
#x <- as.data.frame(as.matrix(ellipses_conf[,1:2]) %*% rot) ## rotated configurations
#x <- ellipses_conf[,1:2]

#ellipses_conf <- cbind(ellipses_conf$ID, x)
colnames(ellipses_conf) <- c("ID","D1","D2")

centroids <- as_tibble(bootRogers$conf) 
colnames(centroids) <- c("D1","D2")

centroids <- centroids %>% 
  mutate(D1 = D1 *dilation,
         D2 = D2 *dilation)

  
#theta <- 326*pi/180 ## degrees to radians
#rot <- matrix(c(cos(theta), sin(theta), -sin(theta), cos(theta)), ncol = 2)
#x <- as.data.frame(as.matrix(centroids[,1:2]) %*% rot) ## rotated configurations


#centroids <- x
colnames(centroids) <- c("centroids_D1","centroids_D2")

p <- ggplot(ellipses_conf, aes(x=D1, y=D2)) +
  #geom_point(aes(x=D1, y=D2, colour = mean_titre), shape = 16, alpha = 1, size = 4) +
  #geom_point(aes(x=D1, y=D2), shape = 16, color = "black", alpha = .5, size = 1) +
    geom_polygon(aes(group = ID),color = "black", size = .25, alpha = .7,fill = "#E41A1C") +
  geom_point(data = centroids, aes(x=centroids_D1, y=centroids_D2), shape = 21, color = "black", fill = "black", alpha = 0.8, size = .7) +

  #scale_colour_gradient(low="yellow", high="red") + 
  theme_linedraw() +
  scale_x_continuous(limits = c(min(ellipses_conf$D1), max(ellipses_conf$D1) +.5), breaks=seq(min(ellipses_conf$D1), max(ellipses_conf$D1) + 1, 1)) +
    scale_y_continuous(limits = c(min(ellipses_conf$D2), max(ellipses_conf$D2) + .5), breaks=seq(min(ellipses_conf$D2), max(ellipses_conf$D2+ 1), 1)) +
  theme(panel.grid.major = element_line(colour="grey", size = (0.3)),
        panel.grid.minor = element_blank(),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.background = element_rect(fill="white",
                                  size=0.25, linetype="solid", 
                                  colour ="black")) + 
  guides(size = "none", fill="none") +
coord_fixed() + 
  geom_label(data = data.frame(x = -1.9516 + 12.5, y = -2.748013 + 1.5,label="Stability: 0.988"), aes(x = x, y = y, label = label),
    color = "black",
    fill="white",
    size= 6
  )

p

ggsave("Bootstrap_spneumo_phen.jpg")

```



# Confidence intervals
Given the error inherent in the MIC assay and large datasets, defining confidence intervals for isolate MIC values is useful in determining whether two isolates are truly different, or whether their differences plausibly reflect assay error.

Confidence intervals can be generated using the MDS algorithm. This is done by shifting the position of individual points, while keeping all others frozen in place, until overall stress increases by a set amount. This method allows points to radiate outwards from their original position at each angle of 10 degrees until the stress limit is reached. In this case I have used 1% increase in total stress across the map, but this can be adjusted. These areas are used as pseudo-confidence intervals for each isolate. This code is commented out as it takes a very long time to run, and produces intervals which are similar to the bootstrapping method outlined above. 


```{r, echo = F}
 # Confidence intervals based on maximum-likelihood estimation
    #cres <- confEllipse(torg_met)
    #cres
    
    #plot(cres, plot.dim = c(1,2), eps = .01, label.conf = list(label = FALSE))
    #save(cres, file="pseudo_confidenceintervals_pneumoniae_beta-lactams.RData")
```
    